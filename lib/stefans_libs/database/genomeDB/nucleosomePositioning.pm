package nucleosomePositioning;

#  Copyright (C) 2008 Stefan Lang

#  This program is free software; you can redistribute it
#  and/or modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation;
#  either version 3 of the License, or (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with this program; if not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use stefans_libs::database::variable_table;
use base 'variable_table';

=for comment

This document is in Pod format.  To read this, use a Pod formatter,
like 'perldoc perlpod'.

=head1 NAME

stefans_libs::gbFile

=head1 DESCRIPTION

This class is used to store and get nucleosome positioning data. The data can be generated by the scripts descibed in PIMD:19092803. To work with this database::genomeDB the scripts have been wraped by the script calculateNucleosomePositionings.pl.

=head2 depends on


=cut

=head1 METHODS

=head2 new

new returns a new object reference of the class nucleosomePositioning.

=cut

sub new {

	my ( $class, $dbh, $debug ) = @_;

	die $class, ":new -> we need a object of type DBI at startup (not $dbh)"
	  unless ( defined $dbh && ref($dbh) eq "DBI::db" );

	my ($self);

	$self = {
		'dbh'        => $dbh,
		'debug' => $debug,
		'dataLength' => 1000,
		'select_prob-overall_byID_and_start' =>
"select start, prob_overall from database where gbFiles_id = ? and start > ? and start < ?",
		'select_prob-start_byID_and_start' =>
"select start, prob_start from database where gbFiles_id = ? and start > ? and start < ?",
		'select_prob-overall_for_gbFileID' =>
		  "select prob_overall from database where gbFiles_id = ? ",
		'select_prob-start_for_gbFileID' =>
		  "select prob_start from database where gbFiles_id = ? ",
		'check_existance' =>
		  "select id from database where gbFiles_id = ? && start = 1"
	};

	bless $self, $class if ( $class eq "nucleosomePositioning" );

	$self-> init_tableStructure ();
	
	return $self;

}

sub init_tableStructure {
	my ( $self, $dataset ) = @_;
	my $hash;
	$hash->{'INDICES'}    = [];
	$hash->{'UNIQUES'}    = [];
	$hash->{'variables'}  = [];
	push(
		@{ $hash->{'variables'} },
		{
			'name'         => 'gbFiles_id',
			'type'         => 'INTEGER UNSIGNED',
			'NULL'         => '0',
			'description'  => '',
			'data_handler' => 'gbFilesTable',
			'needed'       => ''
		}
	);
	push(
		@{ $hash->{'variables'} },
		{
			'name'        => 'start',
			'type'        => 'INTEGER UNSIGNED',
			'NULL'        => '0',
			'description' => '',
			'needed'      => ''
		}
	);
	push(
		@{ $hash->{'variables'} },
		{
			'name'        => 'prob_start',
			'type'        => 'TEXT',
			'NULL'        => '0',
			'description' => '',
			'needed'      => ''
		}
	);
	push(
		@{ $hash->{'variables'} },
		{
			'name'        => 'prob_overall',
			'type'        => 'TEXT',
			'NULL'        => '0',
			'description' => '',
			'needed'      => ''
		}
	);
	push( @{ $hash->{'UNIQUES'} }, [ 'gbFiles_id', 'start' ] );
	$hash->{'ENGINE'}           = 'MyISAM';
	$hash->{'CHARACTER_SET'}    = 'latin1';
	$self->{'table_definition'} = $hash;

	$self->{'UNIQUE_KEY'} = ['gbFiles_id', 'start']
	  ; # add here the values you would take to select a single value from the databse

## and now we could add some datahandlers - but that is better done by hand.
##I will add a mark so you know that you should think about that!
	$self->{'data_handler'}->{'gbFilesTable'} = undef;
	return $dataset;
}


sub DataExists {
	my ( $self, $baseName, $gbFile_id ) = @_;
	my $sth = $self->_get_SearchHandle(
		{ 'baseName' => $baseName, 'search_name' => 'check_existance' } );
	unless ( $sth->execute($gbFile_id) ) {
		warn "we got an MySQL error!", $self->{dbh}->errstr();
	}
	my $id;
	$sth->bind_columns( \$id );
	$sth->fetch();

	#warn "\nwe got the ID '$id'\n\n";
	if ( defined $id ) {

		#warn ref($self),":DataExists -> the ID = '$id'\n";
		return 1;
	}
	return 0;
}



=head2 readInDataFile

Add a nucleosome positioning file that was created by the nucleosome_prediction.pl 
script described in publication PMID:19092803. The script is called from calculateNucleosomePositionings.pl.
The user should not use this function. Therefore, the ducumentation is primarily for the developer.

This function takes an hash with the keys 'gbFile_id' and 'datafile' as arguments.
The gbFile_id is checked against the gbFilesTable object, whereas the datafile is
read und processed into the here used table structure.

There is an additional functionality implemented:

=item If you add the key 'start' you can define at which position of the datafile starts 
in comparison with the start of the named gbFile. So only positive integer values < gbFile->Length are usable....

=item If you add the key 'skipp_last' all lines in the datafile > 'skipp_last' are ignored

=item If you add the key 'skipp_first' all lines in the datafile < 'skipp_first' are ignored

 
=cut

sub readInDataFile {
	my ( $self, $dataset ) = @_;

	open( IN, "<$dataset->{'datafile'}" )
	  or die "can not open file '$dataset->{'datafile'}'\n";
	my ( $sth, $i, @occupy, @start, $start_bp, @line, $counts_since_start );
	$counts_since_start = 0;
	$i                  = -1;

	$start_bp = $dataset->{'start'};

	while (<IN>) {
		next if ( $_ =~ m/start/ );
		$i++;
		$counts_since_start++;
		if ( $i == $self->{dataLength} ) {
			if ( @occupy == $self->{dataLength} ) {
				$self->AddDataset(
					{
						'gbFiles' => { 'id' => $dataset->{gbFile_id} },
						'start'  => $start_bp,
						'prob_start'  => join( ";", @start ),
						'prob_overall' => join( ";", @occupy )
					}
				);
			}
			elsif ( defined $occupy[0] ) {
				for ( my $l = 1 ; $l < $self->{dataLength} - @occupy ; $l++ ) {
					unshift( @start,  "0" );
					unshift( @occupy, "0" );
				}
				$self->AddDataset(
					{
						'gbFiles' => { 'id' => $dataset->{gbFile_id} },
						'start'  => $start_bp,
						'prob_start'  => join( ";", @start ),
						'prob_overall' => join( ";", @occupy )
					}
				);
			}
			$i = 0;
			$start_bp += $self->{dataLength};
			@start  = ();
			@occupy = ();
		}

		next
		  if ( defined $dataset->{'skipp_last'}
			&& $counts_since_start > $dataset->{'skipp_last'} );
		next
		  if ( defined $dataset->{'skipp_first'}
			&& $counts_since_start < $dataset->{'skipp_first'} );
		chomp $_;
		@line = ( split( "\t", $_ ) );
		push( @start,  $line[2] );
		push( @occupy, $line[3] );
	}

	if ( @occupy > 0 ) {
		$self->AddDataset(
			{
				'gbFiles' => { 'id' => $dataset->{gbFile_id} },
				'start'  => $start_bp,
				'prob_start'  => join( ";", @start ),
				'prob_overall' => join( ";", @occupy )
			}
		);
	}
	close(IN);
	return 1;
}

sub _check_get_prob_query_data {
	my ( $self, $dataset ) = @_;
	$self->{error} = $self->{warning} = '';
	$self->{error} .=
	  ref($self)
	  . ":_check_get_prob_query_data -> we need the propper table base name ('baseName')\n"
	  unless ( defined defined $dataset->{'baseName'} || $self->TableName() );
	$self->{error} .=
	  ref($self)
	  . ":_check_get_prob_query_data -> we need to know which gbFile ID is of interest ('gbFile_id')"
	  unless ( defined defined $dataset->{'gbFile_id'} );
	$self->{error} .=
	  ref($self)
	  . ":_check_get_prob_query_data -> we need to know the start of the region on interest ('start')"
	  unless ( defined defined $dataset->{'start'} );
	$self->{error} .=
	  ref($self)
	  . ":_check_get_prob_query_data -> we need to know the end of the region on interest ('end')"
	  unless ( defined defined $dataset->{'end'} );
	return 0 if ( $self->{error} =~ m/\w/ );
	return 1;
}

=head2 Get_prob_start_for_region or Get_prob_overall_for_region

=head3 function

return an array of values (either p_overall or p_start) for a region from <start> to <end>
of a gbFile that has to be specified by its gbFile_id. The positions in the array correspond
to the positions in the gbFile as mentioned by the gbFile to tag the gbFeatures. 

=head3 atributes
	
We need an hash with the entries:
	
=over 2

=item baseName 	the abse name of the table to query

=item gbFile_id the id of the gbFile you want to get data for

=item start	the start of the region on the gbFile

=item end the end of that region on the gbFile

=back

=cut

sub Get_prob_start_for_region {
	my ( $self, $dataset ) = @_;

	unless ( $self->_check_get_prob_query_data($dataset) ) {
		die $self->{error};
	}

	#my ( $self, $baseName, $gbID, $start, $end ) = @_;

	unless ( defined $dataset->{'start'} && $dataset->{'start'} > 0 ) {
		$self->{error} .= ref($self)
		  . "you have forgotten to tell us the region you are interested in!\n";
		return $self->Get_prob_start_for_gbFile_id( $dataset->{'baseName'},
			$dataset->{'gbFile_id'} );
	}

	my ($sth);
	$sth = $self->_get_SearchHandle(
		{
			'baseName'    => $dataset->{'baseName'},
			'search_name' => 'select_prob-start_byID_and_start'
		}
	);
	$sth->execute(
		$dataset->{'gbFile_id'},
		$dataset->{'start'} - $self->{'dataLength'},
		$dataset->{'end'}
	  )
	  or die ref($self),
	  ":Get_prob_start_for_region we got no result for query: '",
	  $self->_getSearchString(
		'select_prob-start_byID_and_start',          $dataset->{'gbFile_id'},
		$dataset->{'start'} - $self->{'dataLength'}, $dataset->{'end'}
	  ),
	  ";'\n";
	return $self->_suck_the_sth_start_value( $sth, $dataset->{'start'},
		$dataset->{'end'} );
}

#'select_prob-overall_byID_and_start'

sub Get_prob_overall_for_region {
	my ( $self, $dataset ) = @_;

	unless ( $self->_check_get_prob_query_data($dataset) ) {
		die $self->{error};
	}

	#my ( $self, $baseName, $gbID, $start, $end ) = @_;

	unless ( defined $dataset->{'start'} && $dataset->{'start'} > 0 ) {
		$self->{error} .= ref($self)
		  . "you have forgotten to tell us the region you are interested in!\n";
		return $self->Get_prob_start_for_gbFile_id( $dataset->{'baseName'},
			$dataset->{'gbFile_id'} );
	}

	my ($sth);
	$sth = $self->_get_SearchHandle(
		{
			'baseName'    => $dataset->{'baseName'},
			'search_name' => 'select_prob-overall_byID_and_start'
		}
	);
	$sth->execute(
		$dataset->{'gbFile_id'},
		$dataset->{'start'} - $self->{'dataLength'},
		$dataset->{'end'}
	  )
	  or die ref($self),
	  ":Get_prob_start_for_region we got no result for query: '",
	  $self->_getSearchString(
		'select_prob-overall_byID_and_start',        $dataset->{'gbFile_id'},
		$dataset->{'start'} - $self->{'dataLength'}, $dataset->{'end'}
	  ),
	  ";'\n", $self->{dbh}->errstr();
	return $self->_suck_the_sth_start_value( $sth, $dataset->{'start'},
		$dataset->{'end'} );
}

sub _check_get_probe_query_all {
	my ( $self, $dataset ) = @_;
	$self->{error} = $self->{warning} = '';
	$self->{error} .=
	  ref($self)
	  . ":_check_get_prob_query_data -> we need the propper table base name ('baseName')\n"
	  unless ( defined defined $dataset->{'baseName'} || $self->TableName() );
	$self->{error} .=
	  ref($self)
	  . ":_check_get_prob_query_data -> we need to know which gbFile ID is of interest ('gbFile_id')"
	  unless ( defined defined $dataset->{'gbFile_id'} );
	return 0 if ( $self->{error} =~ m/\w/ );
	return 1;
}

=head2 Get_prob_start_for_gbFile_id or Get_prob_overall_for_gbFile_id

=head3 function

return an array of values (either p_overall or p_start) for
a gbFile that has to be specified by its gbFile_id.

TAKE CARE! Now the positions in the array are one less that the positions mentioned in the gbFile!
We start heer with 0 and in the gbFile the count starts with 1!

=head3 atributes

We need an hash with the entries:
	
=over 2

=item baseName 	the abse name of the table to query

=item gbFile_id the id of the gbFile you want to get data for

=back

=cut

sub Get_prob_overall_for_gbFile_id {
	my ( $self, $dataset ) = @_;
	my ($sth);
	unless ( $self->_check_get_probe_query_all($dataset) ) {
		die $self->{error};
	}

	$sth = $self->_get_SearchHandle(
		{
			'baseName'    => $dataset->{'baseName'},
			'search_name' => 'select_prob-overall_for_gbFileID'
		}
	);
	$sth->execute( $dataset->{'gbFile_id'} )
	  or die ref($self),
	  ":Get_prob_overall_for_gbFile_id -> we got no results for query '",
	  $self->_getSearchString(
		'select_prob-overall_for_gbFileID',
		$dataset->{'gbFile_id'},
		$dataset->{'gbFile_id'}
	  ),
	  ";'\n", $self->{dbh}->errstr();
	return $self->_suck_the_sth($sth);
}

sub Get_prob_start_for_gbFile_id {
	my ( $self, $dataset ) = @_;
	my ($sth);
	$sth = $self->_get_SearchHandle(
		{
			'baseName'    => $dataset->{'baseName'},
			'search_name' => 'select_prob-start_for_gbFileID'
		}
	);
	$sth->execute( $dataset->{'gbFile_id'} )
	  or die ref($self),
	  ":Get_prob_overall_for_gbFile_id -> we got no results for query '",
	  $self->_getSearchString(
		'select_prob-start_for_gbFileID',
		$dataset->{'gbFile_id'},
		$dataset->{'gbFile_id'}
	  ),
	  ";'\n", $self->{dbh}->errstr();
	return $self->_suck_the_sth($sth);
}

sub _suck_the_sth {
	my ( $self, $sth ) = @_;
	my ( $dataString, @return );

	$sth->bind_columns( \$dataString );

	while ( $sth->fetch() ) {
		push( @return, ( split( ";", $dataString ) ) );
	}
	return \@return;
}

sub _suck_the_sth_start_value {
	my ( $self, $sth, $start, $end ) = @_;
	my ( $start_db, $dataString, @data, @return, $overallStart );

#warn ref($self),":_suck_the_sth_start_value -> we got the values ($sth, $start, $end)\n";
	$sth->bind_columns( \$start_db, \$dataString );

	if ( $sth->fetch() ) {

#print ref($self),":_suck_the_sth_start_value -> we got the overall start:  $start_db\n";
		$overallStart = $start_db;
		push( @data, ( split( ";", $dataString ) ) );
	}

	while ( $sth->fetch() ) {
		push( @data, ( split( ";", $dataString ) ) );
	}
	unless ( defined $overallStart ) {
		warn ref($self), ":_suck_the_sth_start_value -> we got no results!!\n";
		return [];
	}

#print "we try to run 'for ( my \$i = $start - $overallStart ; \$i < $end - $overallStart ; \$i++ ) {'\n";
	for ( my $i = $start - $overallStart ; $i <= $end - $overallStart ; $i++ ) {

		#print "we have the value $data[$i] at position $i\n";
		push( @return, $data[$i] );
	}

	return \@return;
}

1;
